package scheduling;

import taskData.Task;


public class Edp {

	public static EdpOutput algo2(PollingServer pollServer) {

		final int Cp = pollServer.getComputationTime();
		final int Tp = pollServer.getPeriod();
		final int Dp = pollServer.getDeadline();
		final TaskSet ET = pollServer.getETSubset();

		final float delta = (float) Tp + (float) Dp - 2 * (float) Cp;
		final float alpha = (float) Cp / (float) Tp;
		int responseTime, worstCaseResponseTime = 0;

		int T = Schedulor.lcm(ET.getTaskCollection());

		for (Task task_i : ET.getTaskCollection()) {
			int t = 0;
			responseTime = task_i.getDeadline() + 1;

			while (t <= T) {
				float supply = originalSupplyFunction(alpha, t, delta);
				int demand = 0;

				for (Task task_j : ET.getTaskCollection()) {
					if (task_j.getTaskPriority() >= task_i.getTaskPriority()) {
						demand += Math.ceil((float) t / task_j.getPeriod()) * task_j.getComputationTime();
					}
				}
				if (supply >= demand && t > 0) {
					responseTime = t;
					worstCaseResponseTime = Math.max(responseTime, worstCaseResponseTime);
					break;
				}
				t++;
			}

			if (responseTime > task_i.getDeadline()) {
				return new EdpOutput(false, worstCaseResponseTime);
			}
		}

		return new EdpOutput(true, worstCaseResponseTime);
	}

	static float originalSupplyFunction(float Alpha, int Time, float Delta) {
		return Math.max(0, Alpha * (Time - Delta));
	}

	static float originalDeltaFunction(PollingServer pollServer) {
		final int Cp = pollServer.getComputationTime();
		final int Tp = pollServer.getPeriod();
		final int Dp = pollServer.getDeadline();
		return (float) Tp + (float) Dp - 2 * (float) Cp;
	}

	static boolean checkIfPollServerOwnsTimeSlot(Task slotOwner, Task pollServer) {
		return slotOwner != null && slotOwner.getTaskName().equals(pollServer.getTaskName());
	}

	public static EdpOutput algo2Extension3Old(PollingServer pollServer, Task[] schedule) {

		final int Cp = pollServer.getComputationTime();
		final int Tp = pollServer.getPeriod();
		final int Dp = pollServer.getDeadline();
		final TaskSet ET = pollServer.getETSubset();

		float delta = originalDeltaFunction(pollServer);
		delta = findMaxDistance(pollServer, schedule);

		final float alpha = (float) Cp / (float) Tp;
		int responseTime = 0;
		int worstCaseResponseTime = 0;
		int T = Schedulor.lcm(ET.getTaskCollection());

		for (Task task_i : ET.getTaskCollection()) {
			int t = 0;
			responseTime = task_i.getDeadline() + 1;

			float supply = 0;
			while (t <= T) {
				supply = originalSupplyFunction(alpha, t, delta);

				int demand = 0;
				for (Task task_j : ET.getTaskCollection()) {
					if (task_j.getTaskPriority() >= task_i.getTaskPriority()) { 
						demand += Math.ceil((float) t / task_j.getPeriod()) * task_j.getComputationTime();
					}
				}
				if (supply >= demand && t > 0) {
					responseTime = t;
					worstCaseResponseTime = Math.max(responseTime, worstCaseResponseTime);
					break;
				}
				t++;
			}

			if (responseTime > task_i.getDeadline()) {
				return new EdpOutput(false, worstCaseResponseTime);
			}
		}

		return new EdpOutput(true, worstCaseResponseTime);
	}

	private static float findMaxDistance(PollingServer pollServer, Task[] schedule) {
		int maxDistance = 0;
		int currentDistance = 0;
		int jobComputationLeft = pollServer.getComputationTime();
		boolean isCountingDistance = schedule[0] != pollServer;
		for (int currentTime = 0; currentTime < schedule.length; currentTime++) {
			if (schedule[currentTime] == (pollServer)) {
				if (isCountingDistance) {
					maxDistance = Math.max(currentDistance, maxDistance);
					currentDistance = 0;
					isCountingDistance = false;
				}
				jobComputationLeft -= 1;
				if (jobComputationLeft == 0) {
					isCountingDistance = true;
					jobComputationLeft = pollServer.getComputationTime();
				}
			} else {
				if (isCountingDistance) {
					currentDistance += 1;
				}
			}
		}
		if (maxDistance == 0) {
			System.out.println("failsafe delta, EDP is only scheduled for 1 job.");
			return originalDeltaFunction(pollServer);
		}
		return maxDistance;
	}

	public static EdpOutput algo2Extension3New(PollingServer pollServer, Task[] schedule) {
		// Cp = Capacity/budget
		// Tp = Polling Task Time Period
		// Dp = Polling Task deadline

		// The function depends on the resulting schedule table generated by a prior EDF
		// simulation.

		final int Cp = pollServer.getComputationTime();
		final int Tp = pollServer.getPeriod();
		final int Dp = pollServer.getDeadline();
		final TaskSet ET = pollServer.getETSubset();

		float delta = (float) Tp + (float) Dp - 2 * (float) Cp;
		final float alpha = (float) Cp / (float) Tp;
		int responseTime = 0;
		int worstCaseResponseTime = 0;
		int T = Schedulor.lcm(ET.getTaskCollection());

		for (Task task_i : ET.getTaskCollection()) {
			int t = 0;
			responseTime = task_i.getDeadline() + 1;

			// Changed:
			float supply = 0;
			while (t <= T) {
				// check if the time slot belongs to pollServer:

				int ownsTimeSlot = checkIfPollServerOwnsTimeSlot(schedule[t], pollServer) ? 1 : 0;
				supply += ownsTimeSlot; // * alpha;

				int demand = 0;
				for (Task task_j : ET.getTaskCollection()) {
					if (task_j.getTaskPriority() >= task_i.getTaskPriority()) { // !task_i.equals(task_j) &&
						demand += Math.ceil((float) t / task_j.getPeriod()) * task_j.getComputationTime();
					}
				}
				if (supply >= demand && t > 0) {
					responseTime = t;
					worstCaseResponseTime = Math.max(responseTime, worstCaseResponseTime); // keep track of the
																							// *worst-case* response
																							// time
					break;
				}
				t++;
			}

			if (responseTime > task_i.getDeadline()) {
				return new EdpOutput(false, worstCaseResponseTime);
			}
		}

		return new EdpOutput(true, worstCaseResponseTime);
	}

}